/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { Serializable } from 'node:child_process';
import { Server } from 'node:net';
/**
 * Object which can be serialized, and has an id string
 */
export interface MessageBase extends Record<string, Serializable | null | undefined> {
    id: string;
}
/**
 * Options for the SockDaemonServer constructor
 */
export interface SockDaemonServerOptions {
    /**
     * Time in milliseconds before the daemon will close if no requests
     * are received. Defaults to `3_600_000` (1 hour)
     */
    idleTimeout?: number;
    /**
     * Time in milliseconds before a connection will be disconnected if
     * it does not make any requests. Defaults to `1000` (1 second)
     */
    connectionTimeout?: number;
}
/**
 * Extend this class to create a SockDaemonService that is used by your
 * daemonScript program to service requests.
 */
export declare abstract class SockDaemonServer<Request extends MessageBase = MessageBase, Response extends MessageBase = MessageBase> {
    #private;
    constructor(options?: SockDaemonServerOptions);
    /**
     * Time in milliseconds before the daemon will close if no requests
     * are received. Defaults to `3_600_000` (1 hour)
     */
    get idleTimeout(): number;
    /**
     * Time in milliseconds before a connection will be disconnected if
     * it does not make any requests. Defaults to `1000` (1 second)
     */
    get connectionTimeout(): number;
    /**
     * The folder where this daemon service stores stuff
     */
    get path(): string;
    /**
     * Path to the socket used by this service
     */
    get socket(): string;
    /**
     * Path where daemon logs are written
     */
    get logFile(): string;
    /**
     * File containing the daemon process ID
     */
    get pidFile(): string;
    /**
     * File containing the numeric mtime of the daemon script, so that it
     * can be restarted on change.
     */
    get mtimeFile(): string;
    /**
     * When listening, the net.Server object
     */
    get server(): Server | undefined;
    /**
     * The name of the service. Must match the value set in the
     * SockDaemonClient class that connects to this service.
     */
    static get serviceName(): string;
    /**
     * Stop listening for requests and close the socket.
     */
    close(): void;
    /**
     * Check if the supplied object is a MessageBase
     */
    isMessage(msg: any): msg is MessageBase;
    isRequest(msg: any): msg is Request;
    /**
     * Method that receives Request objects and returns a
     * Response object to be sent over the socket to the client.
     */
    abstract handle(msg: Request): (Omit<Response, 'id'> & {
        id?: string;
    }) | Promise<Omit<Response, 'id'> & {
        id?: string;
    }>;
    /**
     * Check if a daemon server is already running for this cwd/name,
     * and if so, gracefully exit.
     * Otherwise, start up the server and write process id to the pidFile
     */
    listen(): Promise<void>;
}
//# sourceMappingURL=server.d.ts.map