"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsconfig = void 0;
// load the appropriate tsconfig.json file, and apply the tsimp
// section overrides to it, if found.
// This is designed to be called on demand. It will automatically reload
// the config if the mtime of the located config file changes, and always
// return the same object if it parses to the same values.
const catcher_1 = require("@isaacs/catcher");
const fs_1 = require("fs");
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const walk_up_path_1 = require("walk-up-path");
const debug_js_1 = require("../debug.js");
const ts_sys_cached_js_1 = require("../ts-sys-cached.js");
const diagnostic_js_1 = require("./diagnostic.js");
const cwd = process.cwd();
const filename = process.env.TSIMP_PROJECT || 'tsconfig.json';
let loadedConfig;
let loadedConfigJSON;
// ms between checks to make sure the config hasn't changed.
// overridable just so we can test it without waiting 100ms per test
// in practice, this is more than fast enough for most cases.
/* c8 ignore start */
const STAT_FREQ = Number(process.env.TSIMP_CONFIG_DEBOUNCE ?? 100) || 100;
/* c8 ignore stop */
let lastStat = -1 * STAT_FREQ;
let mtime = -1;
let configPath;
const tsconfig = () => {
    // reload the config when the file mtime changes.
    if (loadedConfig && configPath) {
        if (performance.now() - lastStat > STAT_FREQ) {
            // if the stat fails, that's a change to the file.
            const m = (0, catcher_1.catcher)(() => Number((0, fs_1.statSync)(configPath).mtime));
            if (m === mtime) {
                lastStat = performance.now();
                return loadedConfig;
            }
            /* c8 ignore start */
        }
        else {
            return loadedConfig;
        }
        /* c8 ignore stop */
    }
    for (const dir of (0, walk_up_path_1.walkUp)(cwd)) {
        configPath = (0, path_1.resolve)(dir, filename);
        const readResult = typescript_1.default.readConfigFile(configPath, ts_sys_cached_js_1.readFile);
        const { error, config: { tsimp, ...config }, } = readResult;
        if (error) {
            // cannot read file, keep looking
            /* c8 ignore start */
            if (error.code !== 5083) {
                (0, debug_js_1.warn)('could not load config file', configPath, (0, diagnostic_js_1.report)(error));
            }
            /* c8 ignore stop */
            continue;
        }
        // will definitely have it, because we got a result
        mtime = Number(ts_sys_cached_js_1.readFile.mtimeCache.get(configPath)?.[0]);
        lastStat = performance.now();
        const configWithDefaults = applyOverrides(
        // default rootDir to the folder containing tsconfig, if not
        // set explicitly to something else, so we always have one.
        // also default to recommended setting for node programs
        {
            compilerOptions: {
                rootDir: dir,
                skipLibCheck: true,
                isolatedModules: true,
                esModuleInterop: true,
                lib: ['es2023'],
                target: 'es2022',
                strict: true,
                forceConsistentCasingInFileNames: true,
                // defaults that ts uses when transpiling
                jsx: typescript_1.default.JsxEmit.Preserve,
            },
        }, tsimp ? applyOverrides(config, tsimp) : config);
        const res = applyOverrides(configWithDefaults, {
            compilerOptions: {
                // settings that tsimp depends on, cannot be overridden
                // virtual folder, nothing actually written to disk ever
                outDir: (0, path_1.resolve)('.tsimp-compiled'),
                module: 'nodenext',
                moduleResolution: 'nodenext',
                sourceMap: undefined,
                sourceRoot: (0, path_1.resolve)(dir, configWithDefaults.compilerOptions.rootDir),
                inlineSourceMap: true,
                inlineSources: false,
                declarationMap: false,
                declaration: false,
                noEmit: false,
            },
        });
        const newConfig = typescript_1.default.parseJsonConfigFileContent(res, typescript_1.default.sys, dir);
        const newConfigJSON = JSON.stringify(newConfig);
        if (loadedConfig && newConfigJSON === loadedConfigJSON) {
            // no changes, keep the old one
            return loadedConfig;
        }
        newConfig.options.configFilePath = configPath;
        loadedConfigJSON = newConfigJSON;
        return (loadedConfig = newConfig);
    }
    (0, debug_js_1.error)(`could not find config file named "${filename}", searching from "${cwd}"`);
    process.exit(1);
};
exports.tsconfig = tsconfig;
const applyOverrides = (config, overrides) => {
    if (!overrides ||
        typeof overrides !== 'object' ||
        Array.isArray(overrides) ||
        !config ||
        typeof config !== 'object' ||
        Array.isArray(config)) {
        return overrides;
    }
    return {
        ...overrides,
        ...Object.fromEntries(Object.entries(config)
            .map(([k, v]) => [
            k,
            k in overrides ? applyOverrides(v, overrides[k]) : v,
        ])
            .filter(([_, v]) => v !== undefined)),
    };
};
//# sourceMappingURL=tsconfig.js.map