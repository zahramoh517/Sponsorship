"use strict";
// Get output with full type-checking from the LanguageService.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutputTypeCheck = void 0;
const path_1 = require("path");
const debug_js_1 = require("../debug.js");
const file_versions_js_1 = require("./file-versions.js");
const language_service_js_1 = require("./language-service.js");
const resolve_module_name_literals_js_1 = require("./resolve-module-name-literals.js");
const cwd = process.cwd();
const getOutputTypeCheck = (code, fileName) => {
    const start = performance.now();
    const service = (0, language_service_js_1.getLanguageService)();
    const initialProgram = service.getProgram();
    /* c8 ignore start */
    if (!initialProgram) {
        throw new Error('failed to load TS program');
    }
    /* c8 ignore stop */
    (0, file_versions_js_1.addRootFile)(fileName);
    (0, resolve_module_name_literals_js_1.markFileNameInternal)(fileName);
    (0, file_versions_js_1.updateFileVersion)(fileName, code);
    // if we can't get the source file, then return the code un-compiled.
    // Eg, loading a JS file if allowJs is not set.
    const programBefore = service.getProgram();
    const sf = programBefore?.getSourceFile(fileName);
    /* c8 ignore start */
    if (!sf) {
        (0, debug_js_1.warn)('could not get sourceFile, returning raw contents', fileName);
        return {
            outputText: code,
            diagnostics: [],
        };
    }
    /* c8 ignore stop */
    if (initialProgram && programBefore !== initialProgram) {
        (0, debug_js_1.info)('compiler rebuilt Program', fileName);
    }
    const output = service.getEmitOutput(fileName);
    const diagnostics = service
        .getSemanticDiagnostics(fileName)
        .concat(service.getSyntacticDiagnostics(fileName));
    const programAfter = service.getProgram();
    if (programBefore !== programAfter) {
        (0, debug_js_1.warn)(`service.program changed while compiling ${fileName}`);
    }
    try {
        // these errors *should* be impossible.
        /* c8 ignore start */
        if (output.emitSkipped) {
            return { outputText: undefined, diagnostics };
        }
        if (output.outputFiles.length === 0) {
            throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\n` +
                'This is usually the result of a faulty configuration or import. ' +
                'Make sure there is a `.js`, `.json` or other executable ' +
                'extension with loader attached before `tsimp` available.');
        }
        /* c8 ignore stop */
        return {
            outputText: output.outputFiles[0]?.text,
            diagnostics,
        };
    }
    finally {
        const duration = Math.floor((performance.now() - start) * 1000) / 1000;
        const rel = (0, path_1.relative)(cwd, fileName);
        (0, debug_js_1.info)('emitted with typeCheck', [rel, duration]);
    }
};
exports.getOutputTypeCheck = getOutputTypeCheck;
//# sourceMappingURL=get-output-typecheck.js.map