"use strict";
// Utility to take a mutex lock on starting the daemon server,
// used to prevent thundering herd issues when a lot of clients
// all attempt to start daemons at the same moment.
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartingLock = void 0;
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = require("path");
const rimraf_1 = require("rimraf");
const signal_exit_1 = require("signal-exit");
const locks = new Set();
(0, signal_exit_1.onExit)(() => {
    for (const lock of locks) {
        try {
            locks.delete(lock);
            (0, fs_1.unlinkSync)(lock.path);
            /* c8 ignore next */
        }
        catch { }
    }
});
class StartingLock {
    path;
    handle;
    acquired = false;
    constructor(path) {
        this.path = (0, path_1.resolve)(path, 'starting.lock');
    }
    async acquire() {
        if (this.acquired)
            return;
        try {
            this.handle = await (0, promises_1.open)(this.path, 'wx');
        }
        catch (er) {
            /* c8 ignore start */
            if (er.code !== 'EEXIST') {
                throw er;
            }
            /* c8 ignore stop */
            // should never keep the lock for longer than 2 seconds, so if it's
            // younger than that, it's probably valid, so get out of here.
            if (Date.now() - Number((await (0, promises_1.stat)(this.path)).mtime) < 2000) {
                throw er;
            }
            const n = Number(await (0, promises_1.readFile)(this.path, 'utf8'));
            // if the lock is just garbage, unlink it
            // this may fail if two try to do it in parallel
            await (0, promises_1.unlink)(this.path);
            if (n)
                process.kill(n, 'SIGTERM');
            this.handle = await (0, promises_1.open)(this.path, 'wx');
        }
        // write our pid to the file, and then verify that it's our pid
        // why verify? because another process might have deleted it,
        // AFTER we deleted a stale lock and created ours exclusively.
        await this.handle.write(Buffer.from(String(process.pid) + '\n'));
        await this.handle.close();
        const verify = await (0, promises_1.readFile)(this.path, 'utf8');
        /* c8 ignore start */
        if (verify !== `${process.pid}\n`) {
            throw Object.assign(new Error('failed to acquire lock'), {
                expect: `${process.pid}\n`,
                actual: verify,
            });
        }
        /* c8 ignore stop */
        this.acquired = true;
        locks.add(this);
    }
    async release() {
        if (this.acquired) {
            await (0, rimraf_1.rimraf)(this.path);
        }
        this.acquired = false;
        locks.delete(this);
    }
    async commit() {
        if (this.acquired) {
            await (0, promises_1.rename)(this.path, (0, path_1.resolve)((0, path_1.dirname)(this.path), 'pid'));
        }
        this.acquired = false;
        locks.delete(this);
    }
}
exports.StartingLock = StartingLock;
//# sourceMappingURL=starting-lock.js.map