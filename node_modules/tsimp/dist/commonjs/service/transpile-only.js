"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutputTranspileOnly = exports.getOutputForceESM = exports.getOutputForceCommonJS = void 0;
// get output functions to transpile TS code without typechecking
// Note: this is only used when forcing a given compilation target
// if the emit was skipped, or when diagnostics are suppressed with
// TSIMP_DIAG=ignore, so we don't even bother collecting diagnostics.
const catcher_1 = require("@isaacs/catcher");
const path_1 = require("path");
const typescript_1 = __importDefault(require("typescript"));
const walk_up_path_1 = require("walk-up-path");
const ts_sys_cached_js_1 = require("../ts-sys-cached.js");
const tsconfig_js_1 = require("./tsconfig.js");
const createTranspileOnlyGetOutputFunction = (nodeModuleEmitKind) => {
    const config = (0, tsconfig_js_1.tsconfig)();
    // note: module and moduleResolution are always NodeNext
    const compilerOptions = { ...config.options };
    const tsTranspileModule = createTsTranspileModule({
        compilerOptions,
    });
    return (code, fileName) => {
        const { outputText } = tsTranspileModule(code, {
            fileName,
        }, nodeModuleEmitKind === 'nodeesm'
            ? 'module'
            : nodeModuleEmitKind === 'nodecjs'
                ? 'commonjs'
                : undefined);
        return { outputText, diagnostics: [] };
    };
};
const optionsRedundantWithVerbatimModuleSyntax = new Set([
    'isolatedModules',
    'preserveValueImports',
    'importsNotUsedAsValues',
]);
const createTsTranspileModule = ({ compilerOptions: options = (0, tsconfig_js_1.tsconfig)().options, }) => {
    // Pick up the default set of transpile-only settings from tsc
    // Omit any redunddant with verbatimModuleSyntax, if set.
    //@ts-ignore - type not exported, but it's there.
    for (const option of typescript_1.default.transpileOptionValueCompilerOptions) {
        if (options.verbatimModuleSyntax &&
            optionsRedundantWithVerbatimModuleSyntax.has(option.name)) {
            continue;
        }
        options[option.name] = option.transpileOptionValue;
    }
    // transpileModule does not write anything to disk so there is no need to
    // verify that there are no conflicts between input and output paths.
    options.suppressOutputPathCheck = true;
    // Filename can be non-ts file.
    options.allowNonTsExtensions = true;
    const newLine = typescript_1.default.getNewLineCharacter(options);
    let inputFileName;
    let packageJsonFileName;
    let packageJsonType;
    let sourceFile;
    let outputText;
    // Create a compilerHost object to allow the compiler to read and write files
    const compilerHost = {
        getSourceFile: fileName => fileName === (0, ts_sys_cached_js_1.normalizePath)(inputFileName)
            ? sourceFile
            : /* c8 ignore start */
                undefined,
        /* c8 ignore stop */
        // we only write exactly one file, the output text
        writeFile: (_, text) => {
            outputText = text;
        },
        getDefaultLibFileName: () => 'lib.d.ts',
        useCaseSensitiveFileNames: () => true,
        getCanonicalFileName: fileName => fileName,
        getCurrentDirectory: () => '',
        /* c8 ignore next */
        getNewLine: () => newLine,
        fileExists: (fileName) => (0, path_1.relative)(fileName, inputFileName) === '' ||
            (0, path_1.relative)(fileName, packageJsonFileName) === '',
        readFile: fileName => (0, path_1.relative)(fileName, packageJsonFileName) === ''
            ? `{"type": "${packageJsonType}"}`
            : /* c8 ignore start */
                '',
        /* c8 ignore stop */
        directoryExists: () => true,
        getDirectories: () => [],
    };
    const transpileModule = (input, transpileOptions2, pjType) => {
        // if jsx is specified then treat file as .tsx
        inputFileName = transpileOptions2.fileName;
        const dir = (0, path_1.dirname)(inputFileName);
        packageJsonFileName = dir + '/package.json';
        if (pjType)
            packageJsonType = pjType;
        else {
            for (const d of (0, walk_up_path_1.walkUp)(dir)) {
                const pj = (0, catcher_1.catcher)(() => {
                    const json = (0, ts_sys_cached_js_1.readFile)(d + '/package.json');
                    if (!json)
                        return undefined;
                    const pj = JSON.parse(json);
                    return pj;
                });
                if (pj?.type) {
                    packageJsonType = pj.type;
                    break;
                }
            }
        }
        sourceFile = typescript_1.default.createSourceFile(inputFileName, input, {
            languageVersion: typescript_1.default.getEmitScriptTarget(options),
            impliedNodeFormat: typescript_1.default.getImpliedNodeFormatForFile(typescript_1.default.toPath(inputFileName, '', compilerHost.getCanonicalFileName), 
            /*cache*/ undefined, compilerHost, options),
            setExternalModuleIndicator: typescript_1.default.getSetExternalModuleIndicator(options),
        });
        // Output
        outputText = undefined;
        const program = typescript_1.default.createProgram([inputFileName], options, compilerHost);
        // Emit
        program.emit();
        // unpossible
        /* c8 ignore start */
        if (outputText === undefined) {
            throw new Error('Output generation failed');
        }
        /* c8 ignore stop */
        return { outputText, diagnostics: [] };
    };
    return transpileModule;
};
exports.getOutputForceCommonJS = createTranspileOnlyGetOutputFunction('nodecjs');
exports.getOutputForceESM = createTranspileOnlyGetOutputFunction('nodeesm');
exports.getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();
//# sourceMappingURL=transpile-only.js.map