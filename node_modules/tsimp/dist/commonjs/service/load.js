"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadTranspileOnly = exports.loadTypeCheck = exports.load = void 0;
// Load a module from disk, and compile it.
// Result is cached by fileName + mtime, and cleared when config changes.
const cached_1 = require("@isaacs/cached");
const fs_1 = require("fs");
const path_1 = require("path");
const debug_js_1 = require("../debug.js");
const get_output_file_js_1 = require("../get-output-file.js");
const ts_sys_cached_js_1 = require("../ts-sys-cached.js");
const compile_js_1 = require("./compile.js");
const diagnostic_js_1 = require("./diagnostic.js");
const tsconfig_js_1 = require("./tsconfig.js");
let lastConfig;
const cwd = (0, ts_sys_cached_js_1.getCurrentDirectory)();
let didMkdirp = false;
// { fileName: jsFile, diagnostics: [...] }
const load = (fileName, typeCheck = true, pretty = true) => {
    fileName = (0, path_1.resolve)(fileName);
    const config = (0, tsconfig_js_1.tsconfig)();
    if (lastConfig && config !== lastConfig) {
        compileTypeCheck.cache.clear();
        compileTranspileOnly.cache.clear();
        compileTypeCheck.mtimeCache.clear();
        compileTranspileOnly.mtimeCache.clear();
    }
    lastConfig = config;
    // compile to a file on disk, but only if the source has changed.
    const compile = typeCheck ? compileTypeCheck : compileTranspileOnly;
    const cachedMtime = compile.mtimeCache.get(fileName)?.[0];
    const newMtime = compile.getMtime(fileName);
    const outFile = (0, get_output_file_js_1.getOutputFile)(fileName);
    const cachedResult = compile.cache.get(fileName);
    if (cachedMtime &&
        cachedMtime === newMtime &&
        (0, ts_sys_cached_js_1.fileExists)(outFile) &&
        cachedResult) {
        // saw this one, and have previous build available
        return {
            fileName: outFile,
            diagnostics: (0, diagnostic_js_1.reportAll)(cachedResult.diagnostics, pretty),
        };
    }
    // have to perform the compilation
    const start = performance.now();
    const { outputText, diagnostics } = compile(fileName);
    const duration = Math.floor((performance.now() - start) * 1000) / 1000;
    (0, debug_js_1.info)('compiled', [(0, path_1.relative)(process.cwd(), fileName), duration]);
    /* c8 ignore start */
    if (!outputText) {
        return { diagnostics: (0, diagnostic_js_1.reportAll)(diagnostics, pretty) };
    }
    /* c8 ignore stop */
    if (!didMkdirp) {
        didMkdirp = true;
        (0, fs_1.mkdirSync)((0, path_1.resolve)(cwd, '.tsimp/compiled'), { recursive: true });
    }
    (0, fs_1.writeFileSync)(outFile, outputText);
    return {
        fileName: outFile,
        diagnostics: (0, diagnostic_js_1.reportAll)(diagnostics, pretty),
    };
};
exports.load = load;
const compileTypeCheck = (0, cached_1.cachedMtime)((fileName) => {
    const normalizedFileName = (0, ts_sys_cached_js_1.normalizeSlashes)(fileName);
    /* c8 ignore next */
    const content = (0, ts_sys_cached_js_1.readFile)(fileName) || '';
    return (0, compile_js_1.compile)(content, normalizedFileName, true);
});
const compileTranspileOnly = (0, cached_1.cachedMtime)((fileName) => {
    const normalizedFileName = (0, ts_sys_cached_js_1.normalizeSlashes)(fileName);
    /* c8 ignore next */
    const content = (0, ts_sys_cached_js_1.readFile)(fileName) || '';
    return (0, compile_js_1.compile)(content, normalizedFileName, false);
});
const loadTypeCheck = (path) => (0, exports.load)(path, true);
exports.loadTypeCheck = loadTypeCheck;
const loadTranspileOnly = (path) => (0, exports.load)(path, false);
exports.loadTranspileOnly = loadTranspileOnly;
//# sourceMappingURL=load.js.map