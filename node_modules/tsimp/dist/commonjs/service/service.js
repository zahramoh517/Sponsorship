"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemonServer = exports.daemonScript = exports.serviceName = void 0;
// define the client and server for the persistent daemon that
// does the compilation for the loader hooks.
const node_path_1 = require("node:path");
const node_url_1 = require("node:url");
const sock_daemon_1 = require("sock-daemon");
const url_1 = require("url");
const equivalents_js_1 = require("../equivalents.js");
const get_url_js_1 = require("../get-url.js");
const ts_sys_cached_js_1 = require("../ts-sys-cached.js");
const language_service_js_1 = require("./language-service.js");
const load_js_1 = require("./load.js");
exports.serviceName = 'tsimp';
exports.daemonScript = (0, url_1.fileURLToPath)((0, get_url_js_1.getUrl)('./service/daemon.mjs'));
const findTsFile = (url) => {
    if (String(url).startsWith('file://')) {
        const fileName = (0, url_1.fileURLToPath)(url);
        const { ext } = (0, node_path_1.parse)(fileName);
        const equivs = (0, equivalents_js_1.equivalents)(fileName);
        const checks = (0, equivalents_js_1.isTSExt)(ext)
            ? []
            : equivs?.length
                ? equivs
                : equivalents_js_1.tsExts.map(tsExt => fileName + tsExt);
        checks.unshift(fileName);
        for (const tsFile of [fileName, ...checks]) {
            if ((0, ts_sys_cached_js_1.fileExists)(tsFile)) {
                return tsFile;
            }
        }
    }
};
class DaemonServer extends sock_daemon_1.SockDaemonServer {
    static get serviceName() {
        return exports.serviceName;
    }
    #handlePreload(_) {
        (0, language_service_js_1.getLanguageService)().getProgram();
        return {};
    }
    #handleCompile(request) {
        const sourceFile = findTsFile(request.fileName);
        /* c8 ignore start */
        if (!sourceFile) {
            throw new Error('failed to resolve typescript source for ' + request.fileName);
        }
        /* c8 ignore stop */
        const { fileName, diagnostics } = (0, load_js_1.load)(sourceFile, request.diagMode !== 'ignore', request.pretty);
        return { fileName, diagnostics };
    }
    #handleResolve(request) {
        const { url, parentURL } = request;
        const target = url.startsWith('./') || url.startsWith('../')
            ? String(new URL(url, parentURL))
            : url;
        const tsFile = findTsFile(target);
        if (tsFile) {
            const url = new URL(target);
            url.pathname = (0, node_url_1.pathToFileURL)(tsFile).pathname;
            if (tsFile) {
                return {
                    url: String(url),
                };
            }
        }
        return {};
    }
    handle(request) {
        switch (request.action) {
            case 'compile':
                return this.#handleCompile(request);
            case 'resolve':
                return this.#handleResolve(request);
            case 'preload':
                return this.#handlePreload(request);
        }
    }
}
exports.DaemonServer = DaemonServer;
//# sourceMappingURL=service.js.map