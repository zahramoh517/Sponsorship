/// <reference types="node" resolution-mode="require"/>
import { Socket } from 'net';
import { Ping, Pong } from './ping.js';
import type { MessageBase } from './server.js';
/**
 * Class representing a single request from the SockDaemonClient
 *
 * Created by {@link SockDaemonClient#request}
 *
 * @internal
 */
export declare class ClientRequest<Request extends MessageBase, Response extends MessageBase> {
    #private;
    /**
     * The response returned by the Daemon, if resolved
     */
    response?: Response;
    /**
     * The request sent to the Daemon
     */
    request: Request;
    /**
     * Promise which resolves when the response is received
     */
    promise: Promise<Response>;
    /**
     * Message ID request/response
     */
    id: string;
    constructor(
    /**
     * Request to be sent
     */
    request: Request, 
    /**
     * Signal to abort the request
     */
    signal: AbortSignal | undefined, 
    /**
     * Called on either success or failure
     */
    onFinish: () => void);
    /**
     * Cancel the request and fail the promise
     */
    reject(er: any): void;
    /**
     * Resolve the request with a response
     */
    resolve(r: Response): void;
}
/**
 * Options provided to SockDaemonClient constructor
 */
export interface SockDaemonClientOptions {
    /**
     * The execArgv used when spawning the daemonScript. Defaults to []
     */
    execArgv?: string[];
    /**
     * Set `debug: true` to start daemon in debug logging mode
     */
    debug?: boolean;
}
/**
 * Override this class to create a Client that can talk to the
 * SockDaemonServer you've created.
 *
 * Note that the static `serviceName` and `daemonScript` getters
 * MUST be defined on the extended class, referencing the service
 * name and location of the daemon script.
 */
export declare abstract class SockDaemonClient<Request extends MessageBase = MessageBase, Response extends MessageBase = MessageBase> {
    #private;
    constructor({ debug, execArgv, }?: SockDaemonClientOptions);
    /**
     * Send a PING message to the server. This can be useful when you want
     * to start the daemon, without making any specific request.
     */
    ping(): Promise<Pong & {
        duration: number;
    }>;
    /**
     * Kill the server, if it is running.
     *
     * Attempts to send a SIGHUP to allow for graceful shutdown, but this
     * is not possible on Windows.
     */
    kill(): Promise<void>;
    /**
     * The name of the service. Must match the value set in the
     * SockDaemonServer class this talks to.
     */
    static get serviceName(): string;
    /**
     * The location of the daemon script that starts up the
     * SockDaemonServer service that this client talks to.
     */
    static get daemonScript(): string | URL;
    /**
     * The execArgv that is used when spawning the daemon script.
     */
    get execArgv(): string[];
    /**
     * List of current pending requests
     */
    get requests(): ClientRequest<Request, Response>[];
    /**
     * True if currently connected to the daemon service
     */
    get connected(): boolean;
    /**
     * The folder where this daemon service stores stuff
     */
    get path(): string;
    /**
     * Path to the socket used by this service
     */
    get socket(): string;
    /**
     * Path where daemon logs are written
     */
    get logFile(): string;
    /**
     * Path where the daemonScript mtime is written
     */
    get mtimeFile(): string;
    /**
     * File containing the daemon process ID
     */
    get pidFile(): string;
    /**
     * True if the client is currently connected
     */
    get connection(): Socket | undefined;
    /**
     * Returns true if the object is a {@link MessageBase}
     */
    isMessage(msg: any): msg is MessageBase;
    /**
     * Set to check that a response is valid
     */
    isResponse(msg: any): msg is Response;
    /**
     * Send a request. The `id` property is made optional, because it will
     * be overridden anyway by a generated message ID. Starts the daemon
     * script automatically if not already running, and connects if needed.
     *
     * If an AbortSignal is provided, then the request will be dropped on
     * an abort signal, and the promise rejected with the abort reason, if
     * it has not already been resolved.
     */
    request(msg: Omit<Ping, 'id'>, signal?: AbortSignal): Promise<Pong & {
        duration: number;
    }>;
    request(msg: Omit<Request, 'id'>, signal?: AbortSignal): Promise<Response>;
    /**
     * Immediately disconnect from the server. Pending requests will be
     * replayed on the next connection, unless clear() is called.
     */
    disconnect(): void;
    /**
     * Drop all pending requests
     */
    clear(): void;
}
//# sourceMappingURL=client.d.ts.map