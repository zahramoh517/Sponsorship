"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.socketPostMessage = exports.MessageHost = exports.Reader = exports.message = void 0;
const node_events_1 = __importDefault(require("node:events"));
const message_js_1 = require("./message.js");
Object.defineProperty(exports, "message", { enumerable: true, get: function () { return message_js_1.message; } });
Object.defineProperty(exports, "Reader", { enumerable: true, get: function () { return message_js_1.Reader; } });
class MessageHost extends node_events_1.default {
    #stream;
    #reader;
    #writable = true;
    constructor(stream) {
        super();
        this.#stream = stream;
        this.#reader = new message_js_1.Reader();
        this.#stream.on('data', chunk => this.#onData(chunk));
        this.#stream.on('end', () => (this.#writable = false));
        this.#stream.on('close', () => (this.#writable = false));
        this.#stream.on('error', (er) => this.emit('error', er));
    }
    get writable() {
        return this.#writable;
    }
    end() {
        this.#writable = false;
        this.#stream.end();
    }
    postMessage(msg) {
        if (!this.#writable) {
            throw new Error('cannot postMessage after stream end');
        }
        let header;
        let body;
        try {
            ;
            [header, body] = (0, message_js_1.message)(msg);
        }
        catch (er) {
            this.emit('error', er);
            return;
        }
        this.#stream.write(header);
        this.#stream.write(body);
    }
    #onData(chunk) {
        let msgs;
        try {
            msgs = this.#reader.write(chunk);
        }
        catch (er) {
            return this.emit('error', er);
        }
        for (const msg of msgs) {
            this.emit('message', msg);
        }
    }
    emit(event, ...data) {
        return super.emit(event, ...data);
    }
    on(event, handler) {
        return super.on(event, handler);
    }
}
exports.MessageHost = MessageHost;
const socketPostMessage = (socket) => new MessageHost(socket);
exports.socketPostMessage = socketPostMessage;
//# sourceMappingURL=index.js.map