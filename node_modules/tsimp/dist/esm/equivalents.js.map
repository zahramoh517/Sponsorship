{"version":3,"file":"equivalents.js","sourceRoot":"","sources":["../../src/equivalents.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,MAAM,CAAA;AAE5B,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAU,CAAA;AAC9D,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAU,CAAA;AAI9D,MAAM,CAAC,MAAM,OAAO,GAAG,CAAC,CAAM,EAAc,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;AACjE,MAAM,CAAC,MAAM,OAAO,GAAG,CAAC,CAAM,EAAc,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;AAkBjE,MAAM,CAAC,MAAM,GAAG,GAAW;IACzB,KAAK,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC;IACtB,MAAM,EAAE,CAAC,MAAM,CAAC;IAChB,MAAM,EAAE,CAAC,MAAM,CAAC;IAChB,MAAM,EAAE,CAAC,MAAM,CAAC;IAChB,KAAK,EAAE,CAAC,KAAK,CAAC;IACd,MAAM,EAAE,CAAC,MAAM,CAAC;IAChB,MAAM,EAAE,CAAC,MAAM,CAAC;IAChB,MAAM,EAAE,CAAC,KAAK,EAAE,MAAM,CAAC;CACG,CAAA;AAE5B,MAAM,CAAC,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAA;AACvC,MAAM,CAAC,MAAM,KAAK,GAAG,CAAC,CAAM,EAAsB,EAAE,CAClD,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAA;AAErB,MAAM,CAAC,MAAM,WAAW,GAAG,CACzB,IAAY,EACZ,aAAa,GAAG,KAAK,EACX,EAAE;IACZ,MAAM,EAAE,GAAG,EAAE,GAAG,KAAK,CAAC,IAAI,CAAC,CAAA;IAC3B,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,CAAA;IACxD,MAAM,MAAM,GAAa,EAAE,CAAA;IAC3B,IAAI,KAAK,CAAC,GAAG,CAAC,EAAE;QACd,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAA;KAC5C;IACD,IAAI,aAAa,EAAE;QACjB,MAAM,CAAC,IAAI,CAAC,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAA;KAC3C;IACD,OAAO,MAAM,CAAA;AACf,CAAC,CAAA","sourcesContent":["import { parse } from 'path'\n\nexport const jsExts = ['.js', '.mjs', '.cjs', '.jsx'] as const\nexport const tsExts = ['.ts', '.mts', '.cts', '.tsx'] as const\nexport type JSExt = (typeof jsExts)[number]\nexport type TSExt = (typeof tsExts)[number]\n\nexport const isTSExt = (e: any): e is TSExt => tsExts.includes(e)\nexport const isJSExt = (e: any): e is JSExt => jsExts.includes(e)\n\ntype MapBase = {\n  [k in JSExt]: readonly TSExt[]\n} & {\n  [t in TSExt]: readonly JSExt[]\n}\ninterface ExtMap extends MapBase {\n  '.js': readonly ['.ts', '.tsx']\n  '.mjs': readonly ['.mts']\n  '.cjs': readonly ['.cts']\n  '.jsx': readonly ['.tsx']\n  '.ts': readonly ['.js']\n  '.mts': readonly ['.mjs']\n  '.cts': readonly ['.cjs']\n  '.tsx': readonly ['.js', '.jsx']\n}\n\nexport const map: ExtMap = {\n  '.js': ['.ts', '.tsx'],\n  '.mjs': ['.mts'],\n  '.cjs': ['.cts'],\n  '.jsx': ['.tsx'],\n  '.ts': ['.js'],\n  '.mts': ['.mjs'],\n  '.cts': ['.cjs'],\n  '.tsx': ['.js', '.jsx'],\n} as const satisfies MapBase\n\nexport const allExts = Object.keys(map)\nexport const isExt = (e: any): e is TSExt | JSExt =>\n  allExts.includes(e)\n\nexport const equivalents = (\n  path: string,\n  extensionless = false\n): string[] => {\n  const { ext } = parse(path)\n  const stem = path.substring(0, path.length - ext.length)\n  const equivs: string[] = []\n  if (isExt(ext)) {\n    equivs.push(...map[ext].map(e => stem + e))\n  }\n  if (extensionless) {\n    equivs.push(...allExts.map(e => path + e))\n  }\n  return equivs\n}\n"]}