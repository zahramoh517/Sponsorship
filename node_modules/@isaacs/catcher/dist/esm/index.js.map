{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,MAAM,OAAO,GAAG,MAAM,CAAC,wBAAwB,CAC7C,KAAK,EACL,iBAAiB,CAClB,CAAA;AACD,MAAM,MAAM,GACV,OAAO,IAAI,OAAO,CAAC,QAAQ,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,QAAQ,CAAA;AAkBlE,MAAM,UAAU,OAAO,CACrB,EAAK,EACL,WAAe;IAEf,MAAM,uBAAuB,GAAG,KAAK,CAAC,eAAe,CAAA;IACrD,oBAAoB;IACpB,IAAI,MAAM;QAAE,KAAK,CAAC,eAAe,GAAG,CAAC,CAAA;IACrC,IAAI;QACF,OAAO,EAAE,EAAE,CAAA;KACZ;IAAC,MAAM;QACN,OAAO,WAAW,CAAA;QAClB,oBAAoB;KACrB;YAAS;QACR,oBAAoB;QACpB,IAAI,MAAM;YAAE,KAAK,CAAC,eAAe,GAAG,uBAAuB,CAAA;KAC5D;AACH,CAAC;AAgBD,MAAM,UAAU,SAAS,CAGvB,EAAK,EAAE,WAAe;IACtB,OAAO,CACL,GAAG,CAAI,EACgC,EAAE,CACzC,OAAO,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,CAE9B,CAAA;AACT,CAAC","sourcesContent":["const stlProp = Object.getOwnPropertyDescriptor(\n  Error,\n  'stackTraceLimit'\n)\nconst hasSTL =\n  stlProp && stlProp.writable && typeof stlProp.value === 'number'\n\n/**\n * Run the supplied arity-zero function, and if it throws an error, return the\n * `caughtValue` instead (or `undefined` if not provided).\n *\n * This is *only* safe to do when we know that nothing at any point in the call\n * stack relies on the `Error.stack` property, and only *worth* doing in hot\n * paths where a function is expected to throw often (for example, calling\n * `statSync` on many paths to find the first one that exists).\n */\nexport function catcher<F extends (...a: any[]) => any>(\n  fn: F\n): FindReturnType<OverloadMap<F>, []> | undefined\nexport function catcher<F extends (...a: any[]) => any, E>(\n  fn: F,\n  caughtValue: E\n): FindReturnType<OverloadMap<F>, []> | E\nexport function catcher<F extends (...a: any[]) => any, E>(\n  fn: F,\n  caughtValue?: E\n) {\n  const originalStackTraceLimit = Error.stackTraceLimit\n  /* c8 ignore next */\n  if (hasSTL) Error.stackTraceLimit = 0\n  try {\n    return fn()\n  } catch {\n    return caughtValue\n    /* c8 ignore next */\n  } finally {\n    /* c8 ignore next */\n    if (hasSTL) Error.stackTraceLimit = originalStackTraceLimit\n  }\n}\n\n/**\n * Wrap the supplied function, returning a function that is the equivalent of\n * calling it with {@link catcher}.\n *\n * Returned function will preserve up to 10 overload signatures, adding the\n * return type of the `caughtValue` (or `undefined` if not provided).\n */\nexport function catchWrap<F extends (...a: any[]) => any>(\n  fn: F\n): AddReturnType<F, undefined>\nexport function catchWrap<F extends (...a: any[]) => any, E>(\n  fn: F,\n  caughtValue: E\n): AddReturnType<F, E>\nexport function catchWrap<\n  F extends (...a: any[]) => any,\n  E = undefined\n>(fn: F, caughtValue?: E) {\n  return <P extends unknown[]>(\n    ...a: P\n  ): FindReturnType<OverloadMap<F>, P> | E =>\n    catcher(() => fn(...a), caughtValue) as\n      | FindReturnType<OverloadMap<F>, P>\n      | E\n}\n\n// What follows below is some type gymnastics required to preserve the set of\n// signatures in the function interface when it has multiple overloads.\n\n/**\n * Turn an overload function into a `[Parameters,ReturnType][]` list. Always\n * contains 10 entries, any that do not correspond to a defined function\n * signature are sometimes `[never, unknown]`. and sometimes just fail to\n * extend. Haven't figured out why it works sometimes one way and sometimes\n * another. These are filtered out in the subsequent step if it matches the\n * first type.\n */\nexport type OverloadMapRaw<F> = F extends {\n  (...a: infer A0): infer R0\n  (...a: infer A1): infer R1\n  (...a: infer A2): infer R2\n  (...a: infer A3): infer R3\n  (...a: infer A4): infer R4\n  (...a: infer A5): infer R5\n  (...a: infer A6): infer R6\n  (...a: infer A7): infer R7\n  (...a: infer A8): infer R8\n  (...a: infer A9): infer R9\n}\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3],\n      [NeverUnknown<A4>, R4],\n      [NeverUnknown<A5>, R5],\n      [NeverUnknown<A6>, R6],\n      [NeverUnknown<A7>, R7],\n      [NeverUnknown<A8>, R8],\n      [NeverUnknown<A9>, R9]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n      (...a: infer A3): infer R3\n      (...a: infer A4): infer R4\n      (...a: infer A5): infer R5\n      (...a: infer A6): infer R6\n      (...a: infer A7): infer R7\n      (...a: infer A8): infer R8\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3],\n      [NeverUnknown<A4>, R4],\n      [NeverUnknown<A5>, R5],\n      [NeverUnknown<A6>, R6],\n      [NeverUnknown<A7>, R7],\n      [NeverUnknown<A8>, R8]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n      (...a: infer A3): infer R3\n      (...a: infer A4): infer R4\n      (...a: infer A5): infer R5\n      (...a: infer A6): infer R6\n      (...a: infer A7): infer R7\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3],\n      [NeverUnknown<A4>, R4],\n      [NeverUnknown<A5>, R5],\n      [NeverUnknown<A6>, R6],\n      [NeverUnknown<A7>, R7]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n      (...a: infer A3): infer R3\n      (...a: infer A4): infer R4\n      (...a: infer A5): infer R5\n      (...a: infer A6): infer R6\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3],\n      [NeverUnknown<A4>, R4],\n      [NeverUnknown<A5>, R5],\n      [NeverUnknown<A6>, R6]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n      (...a: infer A3): infer R3\n      (...a: infer A4): infer R4\n      (...a: infer A5): infer R5\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3],\n      [NeverUnknown<A4>, R4],\n      [NeverUnknown<A5>, R5]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n      (...a: infer A3): infer R3\n      (...a: infer A4): infer R4\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3],\n      [NeverUnknown<A4>, R4]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n      (...a: infer A3): infer R3\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2],\n      [NeverUnknown<A3>, R3]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n      (...a: infer A2): infer R2\n    }\n  ? [\n      [NeverUnknown<A0>, R0],\n      [NeverUnknown<A1>, R1],\n      [NeverUnknown<A2>, R2]\n    ]\n  : F extends {\n      (...a: infer A0): infer R0\n      (...a: infer A1): infer R1\n    }\n  ? [[NeverUnknown<A0>, R0], [NeverUnknown<A1>, R1]]\n  : F extends (...a: infer A0) => infer R0\n  ? [[NeverUnknown<A0>, R0]]\n  : never\n\n/**\n * The same as {@link OverloadMapRaw}, but with the `[never, unknown]`\n * entries filtered out.\n */\nexport type OverloadMap<F extends (...a: any[]) => any> =\n  FilterNeverMap<OverloadMapRaw<F>>\n\n/**\n * Filter [never,unknown] out of a list\n */\nexport type FilterNeverMap<L> = L extends [h: infer H, ...t: infer T]\n  ? [never, unknown] extends H\n    ? FilterNeverMap<T>\n    : [H, ...FilterNeverMap<T>]\n  : []\n\n/**\n * Look up the return type for a Parameters tuple from the\n * filtered overload map\n */\nexport type FindReturnType<M, P extends unknown[]> = M extends [\n  h: infer H,\n  ...t: infer T\n]\n  ? H extends [P, infer R]\n    ? R\n    : FindReturnType<T, P>\n  : never\n\n/**\n * Add a given return type to all entries in an overload map\n */\nexport type AddReturnTypeToOverloadMap<L, A = undefined> = L extends [\n  infer H,\n  ...infer T\n]\n  ? H extends [unknown[], unknown]\n    ? [[H[0], H[1] | A], ...AddReturnTypeToOverloadMap<T, A>]\n    : []\n  : []\n\n/**\n * Add a given return type to all function signatures of a function type\n */\ntype AddReturnType<\n  F extends (...a: any) => any,\n  A = undefined\n> = MakeOverloadFunction<\n  AddReturnTypeToOverloadMap<OverloadMap<F>, A>\n>\n\n/**\n * Convert a filtered overload map back into a function type\n */\ntype MakeOverloadFunction<L extends [unknown[], unknown][]> =\n  L extends [infer H, ...infer T]\n    ? H extends [unknown[], unknown]\n      ? {\n          (...p: H[0]): H[1]\n        } & (T extends [unknown[], unknown][]\n          ? MakeOverloadFunction<T>\n          : {})\n      : {}\n    : {}\n\n/**\n * Convert all `unknown[]` types in an array type to `never`\n *\n * The `(...? true: false) extends true` prevents it filtering out\n * `any[]`, the only other type that `unknown[]` extends.\n */\nexport type NeverUnknown<T extends unknown[]> = unknown[] extends T\n  ? (T extends {}[] ? true : false) extends true\n    ? any[]\n    : never\n  : T\n"]}