"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = require("node:fs");
const node_module_1 = __importDefault(require("node:module"));
const node_path_1 = require("node:path");
const node_util_1 = require("node:util");
const pirates_1 = require("pirates");
const diagnostic_mode_js_1 = require("../diagnostic-mode.js");
const equivalents_js_1 = require("../equivalents.js");
const get_output_file_js_1 = require("../get-output-file.js");
const require_commonjs_load_js_1 = require("../require-commonjs-load.js");
const ts_sys_cached_js_1 = require("../ts-sys-cached.js");
let svcLoad = undefined;
const diagMode = (0, diagnostic_mode_js_1.getDiagMode)();
const ModuleWithLoad = node_module_1.default;
const { _resolveFilename: originalResolve } = ModuleWithLoad;
// As of node 21, we still must patch this method, because it is
// called *prior* to the resolve hook for require(), and will fail
// if it ends up pointing to a file that doesn't exist, even though
// the load hook can load it just fine.
Object.assign(node_module_1.default, {
    _resolveFilename: (request, parent) => {
        if (parent &&
            (request.startsWith('../') || request.startsWith('./'))) {
            const target = (0, node_path_1.resolve)((0, node_path_1.dirname)(parent.filename), request);
            const equiv = (0, equivalents_js_1.equivalents)(target, true);
            if (equiv && !(0, ts_sys_cached_js_1.fileExists)(target)) {
                for (const target of equiv) {
                    if ((0, ts_sys_cached_js_1.fileExists)(target)) {
                        return originalResolve(target, parent);
                    }
                }
            }
        }
        return originalResolve(request, parent);
    },
});
// Note: this incurs a *significant* per-process overhead if we need to
// do the actual compilation! Thankfully, by the time this is hit, we've
// probably already precompiled it in the resolve hook.
// Only add this hook if we're on a node version that cannot provide
// source in the load hook for commonjs. This functionality was added
// at the same time as --import and Module.register, so test that.
/* c8 ignore start */
if (typeof node_module_1.default.register !== 'function') {
    const consoleError = (...msg) => (0, node_fs_1.writeSync)(1, (0, node_util_1.format)(...msg) + '\n');
    (0, pirates_1.addHook)((code, fileName) => {
        if (fileName.endsWith('.js') && code)
            return code;
        let outputFile = (0, get_output_file_js_1.getOutputFile)(fileName);
        const tx = (0, ts_sys_cached_js_1.readFile)(outputFile);
        if (tx)
            return tx;
        // have to do the full transpile inline.
        if (!svcLoad) {
            svcLoad = (0, require_commonjs_load_js_1.requireCommonJSLoad)();
        }
        const { fileName: file, diagnostics } = svcLoad.load(fileName);
        if (diagnostics.length && diagMode !== 'ignore') {
            for (const d of diagnostics)
                consoleError(d);
            if (diagMode === 'error')
                process.exit(1);
        }
        return (file ? (0, ts_sys_cached_js_1.readFile)(file) : code) || code;
    }, { exts: ['.ts', '.cts'], ignoreNodeModules: true });
}
/* c8 ignore stop */
//# sourceMappingURL=require.js.map