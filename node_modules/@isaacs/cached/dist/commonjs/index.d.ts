/**
 * Cache an arbitrary function of arity 0 or 1.
 * May provide an optional `Map<argType, returnType>`, or one will be created.
 */
export declare function cached<R>(fn: () => R, cache?: MapLike<undefined, R> | undefined): (() => R) & {
    cache: Map<undefined, R>;
};
export declare function cached<A, R>(fn: (arg: A) => R, cache?: MapLike<A, R> | undefined): ((arg: A) => R) & {
    cache: Map<A, R>;
};
/**
 * Defaults to a normal `Map` if not provided, but anything with
 * get/set/has/delete will work. For example:
 * <https://isaacs.github.io/node-lru-cache/>
 */
export interface MapLike<K, V> {
    get: (key: K) => V | undefined;
    has: (key: K) => boolean;
    set: (key: K, value: V) => MapLike<K, V>;
    delete: (key: K) => boolean;
    clear: () => void;
}
/**
 * Return type of cachedMtime()
 */
export type MtimeCachedMethod<R> = {
    (path: string): R;
    /**
     * cache of mtime values and the most recent peformance.now() value
     * when the statSync was performed to read it.
     */
    mtimeCache: MapLike<string, [mtime: number, lastStatTime: number]>;
    /** return value cache */
    cache: MapLike<string, R>;
    /**
     * Get the numeric mtime value for a given path, if possible.
     * Will `statSync()` the file if the mtime is not in the cache, or if
     * the time since the lastStatTime is greater than the `statFreqMs`
     * provided to {@link cachedMtime}.
     */
    getMtime: (path: string) => number | undefined;
};
/**
 * Cache a synchronous FS function that takes a path as a single argument.
 * The result cache will be invalidated whenever the mtime of the path
 * changes. May specify minimum time between stat() calls in ms, and provide
 * both a results cache and mtime cache.
 */
export declare function cachedMtime<R>(fn: (path: string) => R, statFreqMs?: number, cache?: MapLike<string, R>, mtimeCache?: MapLike<string, [
    mtime: number,
    lastStatTime: number
]>): MtimeCachedMethod<R>;
//# sourceMappingURL=index.d.ts.map