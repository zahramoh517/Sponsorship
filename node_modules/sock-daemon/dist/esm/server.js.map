{"version":3,"file":"server.js","sourceRoot":"","sources":["../../src/server.ts"],"names":[],"mappings":"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","sourcesContent":["import { Serializable } from 'node:child_process'\nimport { unlinkSync } from 'node:fs'\nimport { mkdir, readFile, stat, unlink, writeFile } from 'node:fs/promises'\nimport { connect, createServer, Server } from 'node:net'\nimport { resolve } from 'node:path'\nimport { onExit } from 'signal-exit'\nimport { message, socketPostMessage } from 'socket-post-message'\nimport { isPing, isPong, ping, Pong, pong } from './ping.js'\nimport { reportReady } from './report-ready.js'\nimport { StartingLock } from './starting-lock.js'\n\n// put undefined in the type just so that ts allows checking\n// for undefined being in the set, even though it isn't there.\nconst socketExistCodes: Set<string | undefined> = new Set([\n  'EEXIST',\n  'EADDRINUSE',\n])\n\nconst cwd = process.cwd()\nconst isWindows = process.platform === 'win32'\n/* c8 ignore start */\nconst log = /\\bSOCK-?DAEMON\\b/i.test(process.env.NODE_DEBUG ?? '')\n  ? (...msg: any[]) => {\n      console.error(process.pid, ...msg)\n    }\n  : () => {}\n/* c8 ignore stop */\n\n/**\n * Object which can be serialized, and has an id string\n */\nexport interface MessageBase\n  extends Record<string, Serializable | null | undefined> {\n  id: string\n}\n\n/**\n * Options for the SockDaemonServer constructor\n */\nexport interface SockDaemonServerOptions {\n  /**\n   * Time in milliseconds before the daemon will close if no requests\n   * are received. Defaults to `3_600_000` (1 hour)\n   */\n  idleTimeout?: number\n  /**\n   * Time in milliseconds before a connection will be disconnected if\n   * it does not make any requests. Defaults to `1000` (1 second)\n   */\n  connectionTimeout?: number\n}\n\n/**\n * Extend this class to create a SockDaemonService that is used by your\n * daemonScript program to service requests.\n */\nexport abstract class SockDaemonServer<\n  Request extends MessageBase = MessageBase,\n  Response extends MessageBase = MessageBase\n> {\n  #name: string\n  #server?: Server\n  #connectionTimeout: number = 1_000\n  #idleTimeout: number = 60 * 60 * 1000\n  #idleTimer?: NodeJS.Timeout\n  #path: string\n  #socket: string\n  #pidFile: string\n  #logFile: string\n  #mtimeFile: string\n  #didOnExit = false\n  #daemonScript?: string\n  #startingLock: StartingLock\n\n  constructor(options: SockDaemonServerOptions = {}) {\n    this.#name = (\n      this.constructor as typeof SockDaemonServer\n    ).serviceName\n    if (typeof options.connectionTimeout === 'number') {\n      this.#connectionTimeout = options.connectionTimeout\n    }\n    if (typeof options.idleTimeout === 'number') {\n      this.#idleTimeout = options.idleTimeout\n    }\n    this.#path = resolve(cwd, `.${this.#name}`, 'daemon')\n    this.#socket = resolve(this.#path, 'socket')\n    /* c8 ignore start */\n    if (isWindows) {\n      this.#socket = resolve('//?/pipe/' + this.#socket)\n    }\n    /* c8 ignore stop */\n    this.#mtimeFile = resolve(this.#path, 'mtime')\n    this.#pidFile = resolve(this.#path, 'pid')\n    this.#logFile = resolve(this.#path, 'log')\n    this.#startingLock = new StartingLock(this.#path)\n    this.#daemonScript =\n      process.env[`SOCK_DAEMON_SCRIPT_${this.#name}`]\n  }\n\n  /**\n   * Time in milliseconds before the daemon will close if no requests\n   * are received. Defaults to `3_600_000` (1 hour)\n   */\n  get idleTimeout() {\n    return this.#idleTimeout\n  }\n\n  /**\n   * Time in milliseconds before a connection will be disconnected if\n   * it does not make any requests. Defaults to `1000` (1 second)\n   */\n  get connectionTimeout() {\n    return this.#connectionTimeout\n  }\n\n  /**\n   * The folder where this daemon service stores stuff\n   */\n  get path() {\n    return this.#path\n  }\n\n  /**\n   * Path to the socket used by this service\n   */\n  get socket() {\n    return this.#socket\n  }\n\n  /**\n   * Path where daemon logs are written\n   */\n  get logFile() {\n    return this.#logFile\n  }\n\n  /**\n   * File containing the daemon process ID\n   */\n  get pidFile() {\n    return this.#pidFile\n  }\n\n  /**\n   * File containing the numeric mtime of the daemon script, so that it\n   * can be restarted on change.\n   */\n  get mtimeFile() {\n    return this.#mtimeFile\n  }\n\n  /**\n   * When listening, the net.Server object\n   */\n  get server() {\n    return this.#server\n  }\n\n  /**\n   * The name of the service. Must match the value set in the\n   * SockDaemonClient class that connects to this service.\n   */\n  static get serviceName(): string {\n    throw new Error(\n      `${this.constructor.name} class must define static 'serviceName' getter`\n    )\n  }\n\n  #idleTick(n = this.#idleTimeout) {\n    /* c8 ignore next */\n    if (this.#idleTimer) clearTimeout(this.#idleTimer)\n    /* c8 ignore next */\n    if (!this.#idleTimeout) return\n    this.#idleTimer = setTimeout(() => this.close(), n)\n    this.#idleTimer.unref()\n  }\n\n  /**\n   * Stop listening for requests and close the socket.\n   */\n  close() {\n    /* c8 ignore next */\n    if (!this.#server) return\n    log('close server')\n    this.#server.close()\n    this.#server = undefined\n    try {\n      unlinkSync(this.#pidFile)\n      /* c8 ignore next */\n    } catch {}\n  }\n\n  /**\n   * Check if the supplied object is a MessageBase\n   */\n  isMessage(msg: any): msg is MessageBase {\n    return (\n      !!msg &&\n      typeof msg === 'object' &&\n      !Array.isArray(msg) &&\n      typeof msg.id === 'string'\n    )\n  }\n\n  isRequest(msg: any): msg is Request {\n    return this.isMessage(msg)\n  }\n\n  /**\n   * Method that receives Request objects and returns a\n   * Response object to be sent over the socket to the client.\n   */\n  abstract handle(\n    msg: Request\n  ):\n    | (Omit<Response, 'id'> & { id?: string })\n    | Promise<Omit<Response, 'id'> & { id?: string }>\n\n  /**\n   * Check if a daemon server is already running for this cwd/name,\n   * and if so, gracefully exit.\n   * Otherwise, start up the server and write process id to the pidFile\n   */\n  async listen(): Promise<void> {\n    await mkdir(this.#path, { recursive: true })\n    try {\n      await this.#startingLock.acquire()\n      return this.#listen()\n      /* c8 ignore start */\n    } catch {\n      return this.#tryConnect(1000)\n    }\n    /* c8 ignore stop */\n  }\n\n  // try to listen, and if we get an EEXIST or EADDRINUSE, then\n  // connect and ping. If the ping fails, usurp.\n  async #listen() {\n    // impossible by design\n    /* c8 ignore start */\n    if (!this.#startingLock.acquired) {\n      throw new Error('#listen() called without first acquiring lock')\n    }\n    /* c8 ignore stop */\n\n    // if we don't get some kind of request in the first 10 seconds,\n    // just close, probably a thundering herd issue.\n    this.#idleTick(10_000)\n\n    const server = createServer(conn => {\n      const messageHost = socketPostMessage(conn)\n      if (this.#connectionTimeout) {\n        conn.setTimeout(this.#connectionTimeout)\n      }\n      messageHost.on('message', async msg => {\n        if (isPing(msg)) {\n          // pings don't count towards idle timeout\n          // write pongs as a single data write\n          const [phead, pbody] = message(pong(msg))\n          conn.write(Buffer.concat([phead, pbody]))\n          return\n        }\n        this.#idleTick()\n        if (!this.isRequest(msg)) return\n        messageHost.postMessage({\n          ...(await this.handle(msg as Request)),\n          id: msg.id,\n        })\n      })\n      /* c8 ignore start */\n      conn.on('timeout', () => conn.destroy())\n      messageHost.on('error', () => conn.destroy())\n      conn.on('error', () => conn.destroy())\n      /* c8 ignore stop */\n    })\n\n    server.on('error', er => this.#onServerError(er))\n    server.listen(this.#socket, () => this.#onListen(server))\n\n    if (!this.#didOnExit) {\n      onExit(() => this.close())\n      this.#didOnExit = true\n    }\n  }\n\n  async #onServerError(er: Error) {\n    const { code } = er as NodeJS.ErrnoException\n    if (socketExistCodes.has(code)) {\n      log('listen failed', code)\n      return this.#tryConnect(500)\n      /* c8 ignore start */\n    } else {\n      log('server error event', er.message, {\n        ...er,\n      })\n      throw er\n    }\n    /* c8 ignore stop */\n  }\n\n  // AWAIT_PEER state. Try connection for n ms, if it fails, usurp\n  async #tryConnect(n: number) {\n    // try for n ms to connect to the socket\n    // if it fails, usurp\n    let end = performance.now() + n\n    let deferring = false\n    do {\n      await new Promise<void>(res => {\n        const conn = connect(this.#socket)\n        const destroy = () => {\n          conn.destroy()\n          res()\n        }\n        const breakLoop = () => {\n          end = -1\n          destroy()\n        }\n        const messageHost = socketPostMessage(conn)\n\n        conn.setTimeout(\n          Math.max(Math.floor(end - performance.now()), 50)\n        )\n        const id = `${this.#name}-daemon-${process.pid}`\n        const p = ping(id)\n        messageHost.postMessage(p)\n        messageHost.on('message', (msg: Pong) => {\n          if (isPong(msg, p)) {\n            const pid = msg.pid\n            log('deferring to daemon on', pid)\n            reportReady('ALREADY RUNNING')\n            deferring = true\n            /* c8 ignore start */\n            return this.#startingLock\n              .release()\n              .then(() => process.exit())\n          }\n          /* c8 ignore stop */\n          log('not pong, abort connect')\n          breakLoop()\n        })\n\n        // if we get a data event that is not pong, that's a failure\n        conn.on('data', breakLoop)\n\n        conn.on('error', destroy)\n        conn.on('timeout', destroy)\n        messageHost.on('error', destroy)\n        conn.on('end', destroy)\n        conn.on('close', destroy)\n      })\n      /* c8 ignore next */\n    } while (performance.now() < end && !deferring)\n    if (deferring) return\n    // if we get here, it means we must usurp\n    log('failed to connect')\n    return await this.#usurp()\n  }\n\n  async #usurp(): Promise<void> {\n    try {\n      // there should only be one usurper\n      await this.#startingLock.acquire()\n      /* c8 ignore start */\n    } catch {}\n\n    // race condition, this is tested, but flaky to hit precisely\n    /* c8 ignore start */\n    if (!this.#startingLock.acquired) {\n      log('usurp: lock not acquired')\n      return this.#tryConnect(1000)\n    }\n    /* c8 ignore stop */\n\n    log('usurp: lock acquired')\n    await readFile(this.#pidFile, 'utf8')\n      .then(s => process.kill(Number(s), 'SIGTERM'))\n      .catch(log)\n    log('usurp: read pidfile and killed')\n    await Promise.all(\n      [this.#socket, this.#pidFile].map(async f =>\n        unlink(f).catch(log)\n      )\n    )\n    log('usurp: unlinked socket and pidfile')\n    return this.#listen()\n  }\n\n  async #onListen(server: Server) {\n    log('daemon listening')\n    this.#server = server\n    server.removeAllListeners('error')\n    reportReady('READY')\n\n    if (this.#daemonScript) {\n      try {\n        const st = await stat(this.#daemonScript)\n        await writeFile(\n          this.#mtimeFile,\n          String(Number(st.mtime)) + '\\n'\n        )\n        /* c8 ignore next */\n      } catch {}\n    }\n    await this.#startingLock.commit()\n\n    // convenience while testing.\n    /* c8 ignore start */\n    if (process.stdin.isTTY && process.stdout.isTTY) {\n      console.log('press ^D to exit gracefully')\n      process.openStdin()\n      process.stdin.on('end', () => this.close())\n    }\n    /* c8 ignore stop */\n  }\n}\n"]}