{"version":3,"file":"starting-lock.js","sourceRoot":"","sources":["../../src/starting-lock.ts"],"names":[],"mappings":"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","sourcesContent":["// Utility to take a mutex lock on starting the daemon server,\n// used to prevent thundering herd issues when a lot of clients\n// all attempt to start daemons at the same moment.\n\nimport { unlinkSync } from 'fs'\nimport {\n  FileHandle,\n  open,\n  readFile,\n  rename,\n  stat,\n  unlink,\n} from 'fs/promises'\nimport { dirname, resolve } from 'path'\nimport { rimraf } from 'rimraf'\nimport { onExit } from 'signal-exit'\n\nconst locks = new Set<StartingLock>()\nonExit(() => {\n  for (const lock of locks) {\n    try {\n      locks.delete(lock)\n      unlinkSync(lock.path)\n      /* c8 ignore next */\n    } catch {}\n  }\n})\n\nexport class StartingLock {\n  path: string\n  handle?: FileHandle\n  acquired: boolean = false\n\n  constructor(path: string) {\n    this.path = resolve(path, 'starting.lock')\n  }\n\n  async acquire() {\n    if (this.acquired) return\n\n    try {\n      this.handle = await open(this.path, 'wx')\n    } catch (er) {\n      /* c8 ignore start */\n      if ((er as NodeJS.ErrnoException).code !== 'EEXIST') {\n        throw er\n      }\n      /* c8 ignore stop */\n\n      // should never keep the lock for longer than 2 seconds, so if it's\n      // younger than that, it's probably valid, so get out of here.\n      if (Date.now() - Number((await stat(this.path)).mtime) < 2000) {\n        throw er\n      }\n      const n = Number(await readFile(this.path, 'utf8'))\n      // if the lock is just garbage, unlink it\n      // this may fail if two try to do it in parallel\n      await unlink(this.path)\n      if (n) process.kill(n, 'SIGTERM')\n      this.handle = await open(this.path, 'wx')\n    }\n    // write our pid to the file, and then verify that it's our pid\n    // why verify? because another process might have deleted it,\n    // AFTER we deleted a stale lock and created ours exclusively.\n    await this.handle.write(Buffer.from(String(process.pid) + '\\n'))\n    await this.handle.close()\n    const verify = await readFile(this.path, 'utf8')\n    /* c8 ignore start */\n    if (verify !== `${process.pid}\\n`) {\n      throw Object.assign(new Error('failed to acquire lock'), {\n        expect: `${process.pid}\\n`,\n        actual: verify,\n      })\n    }\n    /* c8 ignore stop */\n    this.acquired = true\n    locks.add(this)\n  }\n\n  async release() {\n    if (this.acquired) {\n      await rimraf(this.path)\n    }\n    this.acquired = false\n    locks.delete(this)\n  }\n\n  async commit() {\n    if (this.acquired) {\n      await rename(this.path, resolve(dirname(this.path), 'pid'))\n    }\n    this.acquired = false\n    locks.delete(this)\n  }\n}\n"]}