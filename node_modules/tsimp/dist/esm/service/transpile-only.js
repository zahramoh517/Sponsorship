// get output functions to transpile TS code without typechecking
// Note: this is only used when forcing a given compilation target
// if the emit was skipped, or when diagnostics are suppressed with
// TSIMP_DIAG=ignore, so we don't even bother collecting diagnostics.
import { catcher } from '@isaacs/catcher';
import { dirname, relative } from 'path';
import ts from 'typescript';
import { walkUp } from 'walk-up-path';
import { normalizePath, readFile } from '../ts-sys-cached.js';
import { tsconfig } from './tsconfig.js';
const createTranspileOnlyGetOutputFunction = (nodeModuleEmitKind) => {
    const config = tsconfig();
    // note: module and moduleResolution are always NodeNext
    const compilerOptions = { ...config.options };
    const tsTranspileModule = createTsTranspileModule({
        compilerOptions,
    });
    return (code, fileName) => {
        const { outputText } = tsTranspileModule(code, {
            fileName,
        }, nodeModuleEmitKind === 'nodeesm'
            ? 'module'
            : nodeModuleEmitKind === 'nodecjs'
                ? 'commonjs'
                : undefined);
        return { outputText, diagnostics: [] };
    };
};
const optionsRedundantWithVerbatimModuleSyntax = new Set([
    'isolatedModules',
    'preserveValueImports',
    'importsNotUsedAsValues',
]);
const createTsTranspileModule = ({ compilerOptions: options = tsconfig().options, }) => {
    // Pick up the default set of transpile-only settings from tsc
    // Omit any redunddant with verbatimModuleSyntax, if set.
    //@ts-ignore - type not exported, but it's there.
    for (const option of ts.transpileOptionValueCompilerOptions) {
        if (options.verbatimModuleSyntax &&
            optionsRedundantWithVerbatimModuleSyntax.has(option.name)) {
            continue;
        }
        options[option.name] = option.transpileOptionValue;
    }
    // transpileModule does not write anything to disk so there is no need to
    // verify that there are no conflicts between input and output paths.
    options.suppressOutputPathCheck = true;
    // Filename can be non-ts file.
    options.allowNonTsExtensions = true;
    const newLine = ts.getNewLineCharacter(options);
    let inputFileName;
    let packageJsonFileName;
    let packageJsonType;
    let sourceFile;
    let outputText;
    // Create a compilerHost object to allow the compiler to read and write files
    const compilerHost = {
        getSourceFile: fileName => fileName === normalizePath(inputFileName)
            ? sourceFile
            : /* c8 ignore start */
                undefined,
        /* c8 ignore stop */
        // we only write exactly one file, the output text
        writeFile: (_, text) => {
            outputText = text;
        },
        getDefaultLibFileName: () => 'lib.d.ts',
        useCaseSensitiveFileNames: () => true,
        getCanonicalFileName: fileName => fileName,
        getCurrentDirectory: () => '',
        /* c8 ignore next */
        getNewLine: () => newLine,
        fileExists: (fileName) => relative(fileName, inputFileName) === '' ||
            relative(fileName, packageJsonFileName) === '',
        readFile: fileName => relative(fileName, packageJsonFileName) === ''
            ? `{"type": "${packageJsonType}"}`
            : /* c8 ignore start */
                '',
        /* c8 ignore stop */
        directoryExists: () => true,
        getDirectories: () => [],
    };
    const transpileModule = (input, transpileOptions2, pjType) => {
        // if jsx is specified then treat file as .tsx
        inputFileName = transpileOptions2.fileName;
        const dir = dirname(inputFileName);
        packageJsonFileName = dir + '/package.json';
        if (pjType)
            packageJsonType = pjType;
        else {
            for (const d of walkUp(dir)) {
                const pj = catcher(() => {
                    const json = readFile(d + '/package.json');
                    if (!json)
                        return undefined;
                    const pj = JSON.parse(json);
                    return pj;
                });
                if (pj?.type) {
                    packageJsonType = pj.type;
                    break;
                }
            }
        }
        sourceFile = ts.createSourceFile(inputFileName, input, {
            languageVersion: ts.getEmitScriptTarget(options),
            impliedNodeFormat: ts.getImpliedNodeFormatForFile(ts.toPath(inputFileName, '', compilerHost.getCanonicalFileName), 
            /*cache*/ undefined, compilerHost, options),
            setExternalModuleIndicator: ts.getSetExternalModuleIndicator(options),
        });
        // Output
        outputText = undefined;
        const program = ts.createProgram([inputFileName], options, compilerHost);
        // Emit
        program.emit();
        // unpossible
        /* c8 ignore start */
        if (outputText === undefined) {
            throw new Error('Output generation failed');
        }
        /* c8 ignore stop */
        return { outputText, diagnostics: [] };
    };
    return transpileModule;
};
export const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction('nodecjs');
export const getOutputForceESM = createTranspileOnlyGetOutputFunction('nodeesm');
export const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();
//# sourceMappingURL=transpile-only.js.map