{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAA;AACzC,OAAO,EAAE,QAAQ,EAAE,MAAM,IAAI,CAAA;AAc7B,MAAM,UAAU,MAAM,CACpB,EAAkB,EAClB,QAAmC,IAAI,GAAG,EAAoB;IAE9D,OAAO,MAAM,CAAC,MAAM,CAClB,CAAC,GAAO,EAAE,EAAE;QACV,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;QAC1B,IAAI,GAAG,EAAE;YACP,OAAO,KAAK,CAAC,GAAG,CAAC,GAAG,CAAM,CAAA;SAC3B;QACD,MAAM,CAAC,GAAG,EAAE,CAAC,GAAG,CAAC,CAAA;QACjB,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;QACjB,OAAO,CAAC,CAAA;IACV,CAAC,EACD,EAAE,KAAK,EAAE,CACV,CAAA;AACH,CAAC;AAoCD;;;;;GAKG;AACH,MAAM,UAAU,WAAW,CACzB,EAAuB,EACvB,aAAqB,EAAE,EACvB,QAA4B,IAAI,GAAG,EAAa,EAChD,aAGI,IAAI,GAAG,EAA4B;IAEvC,MAAM,GAAG,GAAG,MAAM,CAAC,EAAE,EAAE,KAAK,CAAC,CAAA;IAC7B,MAAM,QAAQ,GAAG,CAAC,IAAY,EAAE,EAAE;QAChC,MAAM,GAAG,GAAG,WAAW,CAAC,GAAG,EAAE,CAAA;QAC7B,MAAM,EAAE,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,CAAA;QACvD,IAAI,GAAG,GAAG,EAAE,CAAC,CAAC,CAAC,GAAG,UAAU,EAAE;YAC5B,MAAM,CAAC,GAAG,OAAO,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,CAAC,CAAA;YACrD,IAAI,OAAO,CAAC,KAAK,QAAQ,EAAE;gBACzB,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;oBAAE,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;gBACnC,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAA;gBAC9B,OAAO,CAAC,CAAA;aACT;iBAAM;gBACL,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;gBACvB,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAA;gBAClB,OAAO,SAAS,CAAA;aACjB;SACF;QACD,OAAO,EAAE,CAAC,CAAC,CAAC,CAAA;IACd,CAAC,CAAA;IACD,OAAO,MAAM,CAAC,MAAM,CAClB,CAAC,IAAY,EAAE,EAAE;QACf,QAAQ,CAAC,IAAI,CAAC,CAAA;QACd,OAAO,GAAG,CAAC,IAAI,CAAC,CAAA;IAClB,CAAC,EACD,EAAE,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,CAChC,CAAA;AACH,CAAC","sourcesContent":["import { catcher } from '@isaacs/catcher'\nimport { statSync } from 'fs'\n\n/**\n * Cache an arbitrary function of arity 0 or 1.\n * May provide an optional `Map<argType, returnType>`, or one will be created.\n */\nexport function cached<R>(\n  fn: () => R,\n  cache?: MapLike<undefined, R> | undefined\n): (() => R) & { cache: Map<undefined, R> }\nexport function cached<A, R>(\n  fn: (arg: A) => R,\n  cache?: MapLike<A, R> | undefined\n): ((arg: A) => R) & { cache: Map<A, R> }\nexport function cached<A, R>(\n  fn: (arg?: A) => R,\n  cache: MapLike<A | undefined, R> = new Map<A | undefined, R>()\n) {\n  return Object.assign(\n    (arg?: A) => {\n      const has = cache.has(arg)\n      if (has) {\n        return cache.get(arg) as R\n      }\n      const r = fn(arg)\n      cache.set(arg, r)\n      return r\n    },\n    { cache }\n  )\n}\n\n/**\n * Defaults to a normal `Map` if not provided, but anything with\n * get/set/has/delete will work. For example:\n * <https://isaacs.github.io/node-lru-cache/>\n */\nexport interface MapLike<K, V> {\n  get: (key: K) => V | undefined\n  has: (key: K) => boolean\n  set: (key: K, value: V) => MapLike<K, V>\n  delete: (key: K) => boolean\n  clear: () => void\n}\n\n/**\n * Return type of cachedMtime()\n */\nexport type MtimeCachedMethod<R> = {\n  (path: string): R\n  /**\n   * cache of mtime values and the most recent peformance.now() value\n   * when the statSync was performed to read it.\n   */\n  mtimeCache: MapLike<string, [mtime: number, lastStatTime: number]>\n  /** return value cache */\n  cache: MapLike<string, R>\n  /**\n   * Get the numeric mtime value for a given path, if possible.\n   * Will `statSync()` the file if the mtime is not in the cache, or if\n   * the time since the lastStatTime is greater than the `statFreqMs`\n   * provided to {@link cachedMtime}.\n   */\n  getMtime: (path: string) => number | undefined\n}\n\n/**\n * Cache a synchronous FS function that takes a path as a single argument.\n * The result cache will be invalidated whenever the mtime of the path\n * changes. May specify minimum time between stat() calls in ms, and provide\n * both a results cache and mtime cache.\n */\nexport function cachedMtime<R>(\n  fn: (path: string) => R,\n  statFreqMs: number = 10,\n  cache: MapLike<string, R> = new Map<string, R>(),\n  mtimeCache: MapLike<\n    string,\n    [mtime: number, lastStatTime: number]\n  > = new Map<string, [number, number]>()\n): MtimeCachedMethod<R> {\n  const cfn = cached(fn, cache)\n  const getMtime = (path: string) => {\n    const now = performance.now()\n    const cm = mtimeCache.get(path) || [0, -1 * statFreqMs]\n    if (now - cm[1] > statFreqMs) {\n      const m = catcher(() => Number(statSync(path).mtime))\n      if (typeof m === 'number') {\n        if (m !== cm[0]) cache.delete(path)\n        mtimeCache.set(path, [m, now])\n        return m\n      } else {\n        mtimeCache.delete(path)\n        cache.delete(path)\n        return undefined\n      }\n    }\n    return cm[0]\n  }\n  return Object.assign(\n    (path: string) => {\n      getMtime(path)\n      return cfn(path)\n    },\n    { mtimeCache, cache, getMtime }\n  )\n}\n"]}