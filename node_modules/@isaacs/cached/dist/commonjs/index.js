"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cachedMtime = exports.cached = void 0;
const catcher_1 = require("@isaacs/catcher");
const fs_1 = require("fs");
function cached(fn, cache = new Map()) {
    return Object.assign((arg) => {
        const has = cache.has(arg);
        if (has) {
            return cache.get(arg);
        }
        const r = fn(arg);
        cache.set(arg, r);
        return r;
    }, { cache });
}
exports.cached = cached;
/**
 * Cache a synchronous FS function that takes a path as a single argument.
 * The result cache will be invalidated whenever the mtime of the path
 * changes. May specify minimum time between stat() calls in ms, and provide
 * both a results cache and mtime cache.
 */
function cachedMtime(fn, statFreqMs = 10, cache = new Map(), mtimeCache = new Map()) {
    const cfn = cached(fn, cache);
    const getMtime = (path) => {
        const now = performance.now();
        const cm = mtimeCache.get(path) || [0, -1 * statFreqMs];
        if (now - cm[1] > statFreqMs) {
            const m = (0, catcher_1.catcher)(() => Number((0, fs_1.statSync)(path).mtime));
            if (typeof m === 'number') {
                if (m !== cm[0])
                    cache.delete(path);
                mtimeCache.set(path, [m, now]);
                return m;
            }
            else {
                mtimeCache.delete(path);
                cache.delete(path);
                return undefined;
            }
        }
        return cm[0];
    };
    return Object.assign((path) => {
        getMtime(path);
        return cfn(path);
    }, { mtimeCache, cache, getMtime });
}
exports.cachedMtime = cachedMtime;
//# sourceMappingURL=index.js.map