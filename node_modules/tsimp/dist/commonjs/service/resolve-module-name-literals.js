"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.markFileNameInternal = exports.getResolveModuleNameLiterals = exports.getModuleResolutionCache = void 0;
const typescript_1 = __importDefault(require("typescript"));
const equivalents_js_1 = require("../equivalents.js");
const ts_sys_cached_js_1 = require("../ts-sys-cached.js");
const file_versions_js_1 = require("./file-versions.js");
const get_canonical_filename_js_1 = require("./get-canonical-filename.js");
const tsconfig_js_1 = require("./tsconfig.js");
// reset cache on config change
let mrc = undefined;
let config = undefined;
const getModuleResolutionCache = () => {
    const newConf = (0, tsconfig_js_1.tsconfig)();
    if (newConf !== config) {
        mrc = undefined;
        config = newConf;
    }
    return (mrc ??
        (mrc = typescript_1.default.createModuleResolutionCache((0, ts_sys_cached_js_1.getCurrentDirectory)(), get_canonical_filename_js_1.getCanonicalFileName, (0, tsconfig_js_1.tsconfig)().options, undefined)));
};
exports.getModuleResolutionCache = getModuleResolutionCache;
const knownInternalFilenames = new Set();
const internalBuckets = new Set(['']);
const moduleBucketRe = /.*\/node_modules\/(?:@[^\/]+\/)?[^\/]+\//;
const getModuleBucket = (filename) => {
    const find = moduleBucketRe.exec(filename);
    if (find)
        return find[0];
    return '';
};
const markBucketOfFilenameInternal = (filename) => internalBuckets.add(getModuleBucket(filename));
const isFileInInternalBucket = (filename) => internalBuckets.has(getModuleBucket(filename));
const isFileKnownToBeInternal = (filename) => knownInternalFilenames.has(filename);
const fixupResolvedModule = (resolvedModule) => {
    const { resolvedFileName } = resolvedModule;
    /* c8 ignore next */
    if (resolvedFileName === undefined)
        return;
    // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]
    // .ts,.mts,.cts is always switched to internal
    // .js is switched on-demand
    /* c8 ignore start */
    if (resolvedModule.isExternalLibraryImport &&
        ((resolvedFileName.endsWith('.ts') &&
            !resolvedFileName.endsWith('.d.ts')) ||
            (resolvedFileName.endsWith('.cts') &&
                !resolvedFileName.endsWith('.d.cts')) ||
            (resolvedFileName.endsWith('.mts') &&
                !resolvedFileName.endsWith('.d.mts')) ||
            isFileKnownToBeInternal(resolvedFileName) ||
            isFileInInternalBucket(resolvedFileName))) {
        resolvedModule.isExternalLibraryImport = false;
    }
    /* c8 ignore stop */
    if (!resolvedModule.isExternalLibraryImport) {
        knownInternalFilenames.add(resolvedFileName);
    }
};
const getResolveModuleNameLiterals = (host) => {
    const resolveModuleNameLiterals = (moduleLiterals, containingFile, redirectedReference, options, containingSourceFile, _reusedNames) => {
        return moduleLiterals.map((moduleLiteral, i) => {
            const moduleName = moduleLiteral.text;
            const mode = containingSourceFile
                ? typescript_1.default.getModeForResolutionAtIndex?.(containingSourceFile, i)
                : /* c8 ignore start */
                    undefined;
            /* c8 ignore stop */
            let { resolvedModule } = typescript_1.default.resolveModuleName(moduleName, containingFile, options, host, (0, exports.getModuleResolutionCache)(), redirectedReference, mode);
            if (!resolvedModule) {
                const lastDotIndex = moduleName.lastIndexOf('.');
                const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';
                if (ext) {
                    const replacements = (0, equivalents_js_1.equivalents)(moduleName, mode !== typescript_1.default.ModuleKind.ESNext);
                    for (const rep of replacements) {
                        ;
                        ({ resolvedModule } = typescript_1.default.resolveModuleName(rep, containingFile, options, host, (0, exports.getModuleResolutionCache)(), redirectedReference, mode));
                        if (resolvedModule)
                            break;
                    }
                }
            }
            if (resolvedModule) {
                fixupResolvedModule(resolvedModule);
            }
            return { resolvedModule };
        });
    };
    return resolveModuleNameLiterals;
};
exports.getResolveModuleNameLiterals = getResolveModuleNameLiterals;
const markFileNameInternal = (fileName) => {
    if (!isFileKnownToBeInternal(fileName)) {
        markBucketOfFilenameInternal(fileName);
    }
    (0, file_versions_js_1.addRootFile)(fileName);
};
exports.markFileNameInternal = markFileNameInternal;
//# sourceMappingURL=resolve-module-name-literals.js.map