{"version":3,"file":"message.js","sourceRoot":"","sources":["../../src/message.ts"],"names":[],"mappings":"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","sourcesContent":["// serialize/deserialize messages on the stream\n// 4 bytes for message length as uint32, then that many\n// bytes for the message.\n\nimport { deserialize, serialize } from 'node:v8'\n\nexport const message = (value: any): [Buffer, Buffer] => {\n  // TODO do the trick with a custom serializer where we serialize it into\n  // an offset, so that the header can be written right into the chunk,\n  // rather than creating a 4-byte buffer for this.\n  const msg = serialize(value)\n  const length = msg.length\n  const header = Buffer.allocUnsafe(4)\n  header.writeUInt32BE(length)\n  return [header, msg]\n}\n\nexport class Reader {\n  #buffer?: Buffer\n  #offset = 0\n  // synchronously returns an array of deserialized messages\n  write(chunk: Buffer): any[] {\n    const messages: any[] = []\n    let chunkOffset = 0\n    while (true) {\n      const messageLength = getMessageLength(\n        this.#buffer,\n        this.#offset,\n        chunk,\n        chunkOffset\n      )\n      if (messageLength === -1) {\n        this.#buffer = !this.#buffer\n          ? chunk\n          : Buffer.concat([\n              this.#buffer.subarray(this.#offset),\n              chunk,\n            ])\n        this.#offset = chunkOffset\n        return messages\n      }\n      // how much of the message+len is in the #buffer\n      const rem = !this.#buffer\n        ? 0\n        : this.#buffer.length - this.#offset\n      const haveAll =\n        chunk.length - chunkOffset + rem >= messageLength + 4\n      if (!haveAll) {\n        this.#buffer = !this.#buffer\n          ? chunk\n          : Buffer.concat([\n              this.#buffer.subarray(this.#offset),\n              chunk,\n            ])\n        this.#offset = chunkOffset\n        return messages\n      }\n      let msg: Buffer\n      if (rem <= 0) {\n        msg = chunk.subarray(\n          chunkOffset + 4,\n          chunkOffset + 4 + messageLength\n        )\n      } else if (rem <= 4) {\n        msg = chunk.subarray(4 - rem, 4 - rem + messageLength)\n      } else {\n        const m1 = this.#buffer!.subarray(4 + this.#offset)\n        const m2 = chunk.subarray(\n          chunkOffset,\n          messageLength - rem + 4\n        )\n        msg = Buffer.concat([m1, m2])\n      }\n      chunkOffset += 4 - rem + messageLength\n      this.#buffer = undefined\n      messages.push(deserialize(msg))\n    }\n  }\n}\n\nconst getMessageLength = (\n  b1: Buffer | undefined,\n  offset1: number,\n  b2: Buffer,\n  offset2: number\n) => {\n  if ((b1 ? b1.length - offset1 : 0) + (b2.length - offset2) < 4) {\n    return -1\n  }\n\n  // get the 4 components of the message length\n  // might be all/partly in b1, starting at offset, or split across them\n  const inB1 = Math.min(4, b1 ? b1.length - offset1 : 0)\n  const a = (\n    !b1 || inB1 <= 0 ? b2[offset2 + 0 - inB1] : b1[offset1 + 0]\n  ) as number\n  const b = (\n    !b1 || inB1 <= 1 ? b2[offset2 + 1 - inB1] : b1[offset1 + 1]\n  ) as number\n  const c = (\n    !b1 || inB1 <= 2 ? b2[offset2 + 2 - inB1] : b1[offset1 + 2]\n  ) as number\n  const d = (\n    !b1 || inB1 <= 3 ? b2[offset2 + 3 - inB1] : b1[offset1 + 3]\n  ) as number\n  return (a << 24) | (b << 16) | (c << 8) | d\n}\n"]}