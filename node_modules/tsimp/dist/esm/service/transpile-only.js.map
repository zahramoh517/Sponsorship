{"version":3,"file":"transpile-only.js","sourceRoot":"","sources":["../../../src/service/transpile-only.ts"],"names":[],"mappings":"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","sourcesContent":["// get output functions to transpile TS code without typechecking\n// Note: this is only used when forcing a given compilation target\n// if the emit was skipped, or when diagnostics are suppressed with\n// TSIMP_DIAG=ignore, so we don't even bother collecting diagnostics.\nimport { catcher } from '@isaacs/catcher'\nimport { dirname, relative } from 'path'\nimport ts from 'typescript'\nimport { walkUp } from 'walk-up-path'\nimport { normalizePath, readFile } from '../ts-sys-cached.js'\nimport { tsconfig } from './tsconfig.js'\n\n// Basic technique lifted from ts-node's transpileOnly method.\n// Create a CompilerHost, and mock the loading of package.json\n// in order to tell it to use the appropriate module type.\n\nexport type NodeModuleEmitKind = 'nodeesm' | 'nodecjs'\n\nconst createTranspileOnlyGetOutputFunction = (\n  nodeModuleEmitKind?: NodeModuleEmitKind\n): ((\n  code: string,\n  fileName: string\n) => {\n  outputText: string | undefined\n  diagnostics: ts.Diagnostic[]\n}) => {\n  const config = tsconfig()\n  // note: module and moduleResolution are always NodeNext\n  const compilerOptions = { ...config.options }\n\n  const tsTranspileModule = createTsTranspileModule({\n    compilerOptions,\n  })\n\n  return (code: string, fileName: string) => {\n    const { outputText } = tsTranspileModule(\n      code,\n      {\n        fileName,\n      },\n      nodeModuleEmitKind === 'nodeesm'\n        ? 'module'\n        : nodeModuleEmitKind === 'nodecjs'\n        ? 'commonjs'\n        : undefined\n    )\n\n    return { outputText, diagnostics: [] }\n  }\n}\n\nconst optionsRedundantWithVerbatimModuleSyntax = new Set([\n  'isolatedModules',\n  'preserveValueImports',\n  'importsNotUsedAsValues',\n])\n\nconst createTsTranspileModule = ({\n  compilerOptions: options = tsconfig().options,\n}: Pick<ts.TranspileOptions, 'compilerOptions'>) => {\n  // Pick up the default set of transpile-only settings from tsc\n  // Omit any redunddant with verbatimModuleSyntax, if set.\n  //@ts-ignore - type not exported, but it's there.\n  for (const option of ts.transpileOptionValueCompilerOptions) {\n    if (\n      options.verbatimModuleSyntax &&\n      optionsRedundantWithVerbatimModuleSyntax.has(option.name)\n    ) {\n      continue\n    }\n\n    options[option.name] = option.transpileOptionValue\n  }\n\n  // transpileModule does not write anything to disk so there is no need to\n  // verify that there are no conflicts between input and output paths.\n  options.suppressOutputPathCheck = true\n\n  // Filename can be non-ts file.\n  options.allowNonTsExtensions = true\n\n  const newLine = (ts as any).getNewLineCharacter(options) as string\n\n  let inputFileName: string\n  let packageJsonFileName: string\n  let packageJsonType: 'module' | 'commonjs'\n  let sourceFile: ts.SourceFile\n  let outputText: string | undefined\n\n  // Create a compilerHost object to allow the compiler to read and write files\n  const compilerHost: ts.CompilerHost = {\n    getSourceFile: fileName =>\n      fileName === normalizePath(inputFileName)\n        ? sourceFile\n        : /* c8 ignore start */\n          undefined,\n    /* c8 ignore stop */\n    // we only write exactly one file, the output text\n    writeFile: (_, text) => {\n      outputText = text\n    },\n    getDefaultLibFileName: () => 'lib.d.ts',\n    useCaseSensitiveFileNames: () => true,\n    getCanonicalFileName: fileName => fileName,\n    getCurrentDirectory: () => '',\n    /* c8 ignore next */\n    getNewLine: () => newLine,\n    fileExists: (fileName): boolean =>\n      relative(fileName, inputFileName) === '' ||\n      relative(fileName, packageJsonFileName) === '',\n    readFile: fileName =>\n      relative(fileName, packageJsonFileName) === ''\n        ? `{\"type\": \"${packageJsonType}\"}`\n        : /* c8 ignore start */\n          '',\n    /* c8 ignore stop */\n    directoryExists: () => true,\n    getDirectories: () => [],\n  }\n\n  const transpileModule = (\n    input: string,\n    transpileOptions2: ts.TranspileOptions,\n    pjType?: 'module' | 'commonjs'\n  ): {\n    outputText: string | undefined\n    diagnostics: ts.Diagnostic[]\n  } => {\n    // if jsx is specified then treat file as .tsx\n    inputFileName = transpileOptions2.fileName as string\n    const dir = dirname(inputFileName)\n    packageJsonFileName = dir + '/package.json'\n    if (pjType) packageJsonType = pjType\n    else {\n      for (const d of walkUp(dir)) {\n        const pj = catcher(() => {\n          const json = readFile(d + '/package.json')\n          if (!json) return undefined\n          const pj = JSON.parse(json) as {\n            type?: 'commonjs' | 'module'\n          }\n          return pj\n        })\n        if (pj?.type) {\n          packageJsonType = pj.type\n          break\n        }\n      }\n    }\n\n    sourceFile = ts.createSourceFile(inputFileName, input, {\n      languageVersion: (ts as any).getEmitScriptTarget(options),\n      impliedNodeFormat: ts.getImpliedNodeFormatForFile(\n        (ts as any).toPath(\n          inputFileName,\n          '',\n          compilerHost.getCanonicalFileName\n        ),\n        /*cache*/ undefined,\n        compilerHost,\n        options\n      ),\n      setExternalModuleIndicator: (\n        ts as any\n      ).getSetExternalModuleIndicator(options),\n    })\n\n    // Output\n    outputText = undefined\n\n    const program = ts.createProgram(\n      [inputFileName],\n      options,\n      compilerHost\n    )\n\n    // Emit\n    program.emit()\n\n    // unpossible\n    /* c8 ignore start */\n    if (outputText === undefined) {\n      throw new Error('Output generation failed')\n    }\n    /* c8 ignore stop */\n\n    return { outputText, diagnostics: [] }\n  }\n\n  return transpileModule\n}\n\nexport const getOutputForceCommonJS =\n  createTranspileOnlyGetOutputFunction('nodecjs')\n\nexport const getOutputForceESM =\n  createTranspileOnlyGetOutputFunction('nodeesm')\n\nexport const getOutputTranspileOnly =\n  createTranspileOnlyGetOutputFunction()\n"]}