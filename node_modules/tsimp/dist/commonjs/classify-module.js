"use strict";
// figure out whether a given module should be interpreted as ESM or CJS
Object.defineProperty(exports, "__esModule", { value: true });
exports.classifyModule = exports.isPackageJsonType = void 0;
const cached_1 = require("@isaacs/cached");
const catcher_1 = require("@isaacs/catcher");
const path_1 = require("path");
const walk_up_path_1 = require("walk-up-path");
const ts_sys_cached_js_1 = require("./ts-sys-cached.js");
const isPackageJsonType = (t) => typeof t === 'string' && (t === 'commonjs' || t === 'module');
exports.isPackageJsonType = isPackageJsonType;
const readPJType = (0, cached_1.cachedMtime)((0, catcher_1.catchWrap)((pj) => {
    const contents = (0, ts_sys_cached_js_1.readFile)(pj);
    if (!contents) {
        return undefined;
    }
    const t = JSON.parse(contents).type;
    return (0, exports.isPackageJsonType)(t) ? t : 'commonjs';
}));
const classifyModule = (fileName) => {
    if (fileName.endsWith('.json')) {
        return 'json';
    }
    if (fileName.endsWith('.cts') || fileName.endsWith('.cjs')) {
        return 'commonjs';
    }
    else if (fileName.endsWith('.mts') || fileName.endsWith('.mjs')) {
        return 'module';
    }
    else {
        for (const dir of (0, walk_up_path_1.walkUp)((0, path_1.dirname)(fileName))) {
            const t = readPJType((0, path_1.resolve)(dir, 'package.json'));
            if (t)
                return t;
        }
    }
    return 'commonjs';
};
exports.classifyModule = classifyModule;
//# sourceMappingURL=classify-module.js.map