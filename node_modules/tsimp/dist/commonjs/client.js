"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemonClient = exports.daemonScript = exports.serviceName = void 0;
const path_1 = require("path");
const sock_daemon_1 = require("sock-daemon");
const url_1 = require("url");
const diagnostic_mode_js_1 = require("./diagnostic-mode.js");
const get_url_js_1 = require("./get-url.js");
exports.serviceName = 'tsimp';
exports.daemonScript = (0, url_1.fileURLToPath)((0, get_url_js_1.getUrl)('./service/daemon.mjs'));
/**
 * Client that can perform various tasks with the TSIMP Daemon
 * process.
 */
class DaemonClient extends sock_daemon_1.SockDaemonClient {
    /**
     * Always 'tsimp'. Used by SockDaemon to know where to put stuff.
     */
    static get serviceName() {
        return exports.serviceName;
    }
    /**
     * Path to the script that is the daemon program for node to run
     * on demand in the background.
     */
    static get daemonScript() {
        return exports.daemonScript;
    }
    /**
     * Explicitly start up the language service, used for type checking
     *
     * This is a slow operation, but it's somewhat rare that you'd need to do
     * this explicitly, since it's done on demand when needed. Mostly this is
     * for testing purposes.
     */
    async preload(req = {}) {
        const { id, ...result } = await this.request({
            action: 'preload',
            ...req,
        });
        return result;
    }
    /**
     * Compile the code contained in `inputFile`.
     *
     * Return the fileName that the resulting JS was written to, and a string[]
     * of diagnostics.
     */
    async compile(inputFile, diagMode = (0, diagnostic_mode_js_1.getDiagMode)(), pretty = !!process.stderr.isTTY) {
        inputFile = (0, path_1.resolve)(inputFile);
        const { fileName, diagnostics } = (await this.request({
            action: 'compile',
            fileName: String((0, url_1.pathToFileURL)(inputFile)),
            diagMode,
            pretty,
        }));
        if (diagMode === 'ignore') {
            diagnostics.length = 0;
        }
        if ((diagMode === 'error' && diagnostics.length) || !fileName) {
            return { diagnostics };
        }
        return {
            fileName,
            diagnostics,
        };
    }
    /**
     * Translate a module identifier like ./src/foo.js into
     * file:///path/to/src/foo.ts
     * A file that isn't .ts or isn't a file:// url is returned as-is.
     */
    async resolve(url, parentURL) {
        return ((await this.request({
            action: 'resolve',
            url,
            parentURL,
        }))?.url ?? url);
    }
}
exports.DaemonClient = DaemonClient;
//# sourceMappingURL=client.js.map